#include "Gameplay.h"
#include "Map.h"
#include "Instruments.h"
#include "Structures.h"
#include "List.h"
#include "TurretsAI.h"

//------Moving_Functions------//
// принимает структуру с информацией об объекте на карте и двумерный массив структур
bool game::performAnAction(GameInfo* gameInfo, MapCell** map)
{
	bool gameIsRunning = true;	// условие выполнение цикла
	bool isMovingRight = true;  // переменная для патрулирующей турели (отвечает за направление движения)
	double timeBeforeGame = clock(); // переменная для отображения времени, затраченного на прохождение уровня
	double timeOnPause = 0.0;	// переменная для хранения времени на паузе
	int sideOfMovingOx = 0;		// переменная для хранения направления движения и количество шагов по оси Ох
	int sideOfMovingOy = 0;		// переменная для хранения направления движения и количество шагов по оси Оу

	while (gameIsRunning == true)
	{
		if (_kbhit()) // Если нажата клавиша
		{
			switch (_getch()) // Читаем клавишу
			{
			case A_LOWER_CASE:
				sideOfMovingOx = -1;
				moveOx(sideOfMovingOx, HERO, gameInfo, map);
				break;

			case D_LOWER_CASE:
				sideOfMovingOx = 1;
				moveOx(sideOfMovingOx, HERO, gameInfo, map);
				break;

			case LEFT_ARROW:
				sideOfMovingOx = -1;
				moveOx(sideOfMovingOx, AIM_DOT, gameInfo, map);
				break;

			case RIGHT_ARROW:
				sideOfMovingOx = 1;
				moveOx(sideOfMovingOx, AIM_DOT, gameInfo, map);
				break;

			case UP_ARROW:
				sideOfMovingOy = -1;
				moveOy(sideOfMovingOy, AIM_DOT, gameInfo, map);
				break;

			case DOWN_ARROW:
				sideOfMovingOy = 1;
				moveOy(sideOfMovingOy, AIM_DOT, gameInfo, map);
				break;

			case SPACE_JUMP:
				jump(HERO, gameInfo, map);
				break;

			case E_LOWER_CASE:
				setPortal(BLUE_PORTAL, gameInfo, map);
				break;

			case Q_LOWER_CASE:
				setPortal(RED_PORTAL, gameInfo, map);
				break;

			case ENTER:
				enterThePortal(HERO, gameInfo, map);
				activateTheButton(gameInfo, map);
				break;

				/*case R_BUTTON_LOWER_CASE:
					replayceTheAimToHero(gameInfo, map);
					break;*/

			case PAUSE:
				timeOnPause += pause(gameInfo, map);
				break;

			case BACKSPACE:
				gameIsRunning = quitTheLevel(gameInfo, map);
				break;

			default:
				break;
			}
		}

		// Запускает ИИ стационарной турели
		game::turretAI(STATIONARY_TURRET, gameInfo, map);

		// Запускает ИИ патрулирующей турели
		game::turretAI(PLATFORM_TURRET, gameInfo, map);

		// Запускает ИИ турели охотника
		game::turretAI(TURRET_HUNTER, gameInfo, map);

		// Проверяет условия конца игры (кончилось ли здоровье, нашел ли игрок выход)
		gameIsRunning = checkGameOverConditions(gameInfo, map, gameIsRunning);

		game::clearScreen(); // Очищаем экран
		game::drawFrame(map, gameInfo); // Отрисовываем кадр
		game::gravity(map, gameInfo); // Имитируем гравитацию
		game::clearScreen(); // Очищаем экран

		// Переменная необходимая для отображения времени, затраченного на прохождение уровня
		double timeAfterAction = clock() - timeOnPause;

		// Вносим информация о затраченном на прохождение уровня времени (в секундах)
		gameInfo->hero.time = (timeAfterAction - timeBeforeGame) / 1000.0;

		if (gameInfo->hero.score > 0)	// если количество очков больше 0, то вычетается одно очко
		{
			gameInfo->hero.score -= 1.02354;
		}
	}
	if (gameInfo->hero.healthPoints <= 0)
	{
		return false;
	}
	else
	{
		return true;
	}
}

//------Moving_Functions------//
// принимает структуру с информацией об объекте на карте и двумерный массив структур
void game::jump(char type, GameInfo* gameInfo, game::MapCell** map)
{
	switch (type)
	{
	case HERO:
		// если под персонажем есть непроходимый блок
		if (map[gameInfo->hero.yCoordinate + 1][gameInfo->hero.xCoordinate].passable == false)
		{
			// Если обе клетки над героем проходимы
			if ((map[gameInfo->hero.yCoordinate - 1][gameInfo->hero.xCoordinate].passable == true) &&
				(map[gameInfo->hero.yCoordinate - 2][gameInfo->hero.xCoordinate].passable == true))
			{
				//удаляем символ героя из текущей ячейки
				list::deleteCurrentElement(&map[gameInfo->hero.yCoordinate][gameInfo->hero.xCoordinate].types, HERO);
				//добавляем в ячейку выше символ героя
				list::addBegin(&map[gameInfo->hero.yCoordinate - 1][gameInfo->hero.xCoordinate].types, HERO);

				// координата героя по оси Оу уменьшается на один
				gameInfo->hero.yCoordinate = gameInfo->hero.yCoordinate - 1;

				game::drawFrame(map, gameInfo);	// отрисовавается кадр

				//удаляем символ героя из текущей ячейки
				list::deleteCurrentElement(&map[gameInfo->hero.yCoordinate][gameInfo->hero.xCoordinate].types, HERO);
				//добавляем в ячейку выше символ героя
				list::addBegin(&map[gameInfo->hero.yCoordinate - 1][gameInfo->hero.xCoordinate].types, HERO);
				// координата героя по оси Оу уменьшается на один
				gameInfo->hero.yCoordinate = gameInfo->hero.yCoordinate - 1;
			}
			// Если проходима только одна клетка
			else if ((map[gameInfo->hero.yCoordinate - 1][gameInfo->hero.xCoordinate].passable == true) &&
				(map[gameInfo->hero.yCoordinate - 2][gameInfo->hero.xCoordinate].passable == false))
			{
				//удаляем символ героя из текущей ячейки
				list::deleteCurrentElement(&map[gameInfo->hero.yCoordinate][gameInfo->hero.xCoordinate].types, HERO);
				//добавляем в ячейку выше символ героя
				list::addBegin(&map[gameInfo->hero.yCoordinate - 1][gameInfo->hero.xCoordinate].types, HERO);
				// координата героя по оси Оу уменьшается на один
				gameInfo->hero.yCoordinate = gameInfo->hero.yCoordinate - 1;
			}

		}
		break;

	case TURRET_HUNTER:
		// если под турелью есть непроходимый блок
		if (map[gameInfo->hunter_turret.yCoordinate + 1][gameInfo->hunter_turret.xCoordinate].passable == false)
		{
			// Если обе клетки над турелью проходимы
			if ((map[gameInfo->hunter_turret.yCoordinate - 1][gameInfo->hunter_turret.xCoordinate].passable == true) &&
				(map[gameInfo->hunter_turret.yCoordinate - 2][gameInfo->hunter_turret.xCoordinate].passable == true))
			{
				//удаляем символ турели из текущей ячейки
				list::deleteCurrentElement(&map[gameInfo->hunter_turret.yCoordinate][gameInfo->hunter_turret.xCoordinate].types, TURRET_HUNTER);
				//добавляем в ячейку выше символ турели
				list::addBegin(&map[gameInfo->hunter_turret.yCoordinate - 1][gameInfo->hunter_turret.xCoordinate].types, TURRET_HUNTER);

				// координата турели по оси Оу уменьшается на один
				gameInfo->hunter_turret.yCoordinate = gameInfo->hunter_turret.yCoordinate - 1;

				game::drawFrame(map, gameInfo);	// отрисовавается кадр

				//удаляем символ турели из текущей ячейки
				list::deleteCurrentElement(&map[gameInfo->hunter_turret.yCoordinate][gameInfo->hunter_turret.xCoordinate].types, TURRET_HUNTER);
				//добавляем в ячейку выше символ турели
				list::addBegin(&map[gameInfo->hunter_turret.yCoordinate - 1][gameInfo->hunter_turret.xCoordinate].types, TURRET_HUNTER);
				// координата турели по оси Оу уменьшается на один
				gameInfo->hunter_turret.yCoordinate = gameInfo->hunter_turret.yCoordinate - 1;
			}
			// если проходима только одна клетка на турелью
			else if ((map[gameInfo->hunter_turret.yCoordinate - 1][gameInfo->hunter_turret.xCoordinate].passable == true) &&
				(map[gameInfo->hunter_turret.yCoordinate - 2][gameInfo->hunter_turret.xCoordinate].passable == false))
			{
				//удаляем символ турели из текущей ячейки
				list::deleteCurrentElement(&map[gameInfo->hunter_turret.yCoordinate][gameInfo->hunter_turret.xCoordinate].types, TURRET_HUNTER);
				//добавляем в ячейку выше символ турели
				list::addBegin(&map[gameInfo->hunter_turret.yCoordinate - 1][gameInfo->hunter_turret.xCoordinate].types, TURRET_HUNTER);
				// координата турели по оси Оу уменьшается на один
				gameInfo->hunter_turret.yCoordinate = gameInfo->hunter_turret.yCoordinate - 1;
			}
		}
		break;
	}
}

// функция перемещения объектов по оси Ox
void game::moveOx(int sideOfMovingOx, char type, GameInfo* gameInfo, game::MapCell** map)
{
	switch (type)
	{
	case AIM_DOT:
		// если в соседней клетке проходимое пространство
		if (map[gameInfo->aim.yCoordinate][gameInfo->aim.xCoordinate + sideOfMovingOx].passable == true &&
			map[gameInfo->aim.yCoordinate][gameInfo->aim.xCoordinate + sideOfMovingOx].types->value != BUTTON &&
			map[gameInfo->aim.yCoordinate][gameInfo->aim.xCoordinate + sideOfMovingOx].types->value != WALL)
		{
			// удаляем символ прицела из текущей ячейки карты
			list::deleteCurrentElement(&map[gameInfo->aim.yCoordinate][gameInfo->aim.xCoordinate].types, AIM_DOT);
			//добавляем в соседнюю ячейку карты символ прицела
			list::addBegin(&map[gameInfo->aim.yCoordinate][gameInfo->aim.xCoordinate + sideOfMovingOx].types, AIM_DOT);
			gameInfo->aim.xCoordinate = gameInfo->aim.xCoordinate + sideOfMovingOx;
		}
		break;

	case HERO:
		// если в соседней клетке проходимое пространство
		if (map[gameInfo->hero.yCoordinate][gameInfo->hero.xCoordinate + sideOfMovingOx].passable == true)
		{
			//удаляем символ героя из текущей ячейки карты
			list::deleteCurrentElement(&map[gameInfo->hero.yCoordinate][gameInfo->hero.xCoordinate].types, HERO);
			//добавляем в соседнюю ячейку карты символ героя
			list::addBegin(&map[gameInfo->hero.yCoordinate][gameInfo->hero.xCoordinate + sideOfMovingOx].types, HERO);
			gameInfo->hero.xCoordinate = gameInfo->hero.xCoordinate + sideOfMovingOx;
		}
		break;

	case TURRET_HUNTER:
		// если в соседней клетке проходимое пространство
		if (map[gameInfo->hunter_turret.yCoordinate][gameInfo->hunter_turret.xCoordinate + sideOfMovingOx].passable == true)
		{
			// из текущей ячейки удаляется символ турели
			list::deleteCurrentElement(&map[gameInfo->hunter_turret.yCoordinate][gameInfo->hunter_turret.xCoordinate].types, TURRET_HUNTER);
			// добавляем в соседнюю ячейку карты символ турели
			list::addBegin(&map[gameInfo->hunter_turret.yCoordinate][gameInfo->hunter_turret.xCoordinate + sideOfMovingOx].types, TURRET_HUNTER);
			gameInfo->hunter_turret.xCoordinate = gameInfo->hunter_turret.xCoordinate + sideOfMovingOx;
		}
		break;

	case STATIONARY_TURRET:
		// если в соседней клетке проходимое пространство
		if (map[gameInfo->stationary_turret.yCoordinate][gameInfo->stationary_turret.xCoordinate + sideOfMovingOx].passable == true)
		{
			// из текущей ячейки удаляется символ турели
			list::deleteCurrentElement(&map[gameInfo->stationary_turret.yCoordinate][gameInfo->stationary_turret.xCoordinate].types, STATIONARY_TURRET);
			// добавляем в соседнюю ячейку карты символ турели
			list::addBegin(&map[gameInfo->stationary_turret.yCoordinate][gameInfo->stationary_turret.xCoordinate + sideOfMovingOx].types, STATIONARY_TURRET);
			gameInfo->stationary_turret.xCoordinate = gameInfo->stationary_turret.xCoordinate + sideOfMovingOx;
		}
		break;

	case PLATFORM_TURRET:
		// если в соседней клетке проходимое пространство
		if (map[gameInfo->platform_turret.yCoordinate][gameInfo->platform_turret.xCoordinate + sideOfMovingOx].passable == true)
		{
			// удаляется символ турели из текущей ячейки
			list::deleteCurrentElement(&map[gameInfo->platform_turret.yCoordinate][gameInfo->platform_turret.xCoordinate].types, PLATFORM_TURRET);
			// добавляем в соседнюю ячейку карты символ турели
			list::addBegin(&map[gameInfo->platform_turret.yCoordinate][gameInfo->platform_turret.xCoordinate + sideOfMovingOx].types, PLATFORM_TURRET);
			gameInfo->platform_turret.xCoordinate = gameInfo->platform_turret.xCoordinate + sideOfMovingOx;
		}
		break;
	}
}

// функция перемещения объектов по оси Oy
void game::moveOy(int sideOfMovingOy, char type, GameInfo* gameInfo, game::MapCell** map)
{
	switch (type)
	{
	case AIM_DOT:
		// если в соседней клетке проходимое пространство
		if (map[gameInfo->aim.yCoordinate + sideOfMovingOy][gameInfo->aim.xCoordinate].passable == true &&
			map[gameInfo->aim.yCoordinate + sideOfMovingOy][gameInfo->aim.xCoordinate].types->value != BUTTON &&
			map[gameInfo->aim.yCoordinate + sideOfMovingOy][gameInfo->aim.xCoordinate].types->value != WALL)
		{
			// удаляем символ прицела из текущей ячейки карты
			list::deleteCurrentElement(&map[gameInfo->aim.yCoordinate][gameInfo->aim.xCoordinate].types, AIM_DOT);
			// добавляем в соседнюю ячейку карты символ прицела
			list::addBegin(&map[gameInfo->aim.yCoordinate + sideOfMovingOy][gameInfo->aim.xCoordinate].types, AIM_DOT);

			gameInfo->aim.yCoordinate = gameInfo->aim.yCoordinate + sideOfMovingOy;
		}
		break;

	case HERO:
		// если в соседней клетке проходимое пространство
		if (map[gameInfo->hero.yCoordinate + sideOfMovingOy][gameInfo->hero.xCoordinate].passable == true)
		{
			// удаляем символ героя из текущей ячейки карты
			list::deleteCurrentElement(&map[gameInfo->hero.yCoordinate][gameInfo->hero.xCoordinate].types, HERO);
			// добавляем соседнюю в ячейку карты символ героя
			list::addBegin(&map[gameInfo->hero.yCoordinate + sideOfMovingOy][gameInfo->hero.xCoordinate].types, HERO);

			gameInfo->hero.yCoordinate = gameInfo->hero.yCoordinate + sideOfMovingOy;
		}
		break;

	case TURRET_HUNTER:
		// если в соседней клетке проходимое пространство
		if (map[gameInfo->hunter_turret.yCoordinate + sideOfMovingOy][gameInfo->hunter_turret.xCoordinate].passable == true)
		{
			// удаляем символ турели из текущей ячейки карты
			list::deleteCurrentElement(&map[gameInfo->hunter_turret.yCoordinate][gameInfo->hunter_turret.xCoordinate].types, TURRET_HUNTER);
			// добавляем в соседнюю ячейку карты символ турели
			list::addBegin(&map[gameInfo->hunter_turret.yCoordinate + sideOfMovingOy][gameInfo->hunter_turret.xCoordinate].types, TURRET_HUNTER);

			gameInfo->hunter_turret.yCoordinate = gameInfo->hunter_turret.yCoordinate + sideOfMovingOy;
		}
		break;

	case STATIONARY_TURRET:
		// если в соседней клетке проходимое пространство
		if (map[gameInfo->stationary_turret.yCoordinate + sideOfMovingOy][gameInfo->stationary_turret.xCoordinate].passable == true)
		{
			// удаляем символ турели из текущей ячейки карты
			list::deleteCurrentElement(&map[gameInfo->stationary_turret.yCoordinate][gameInfo->stationary_turret.xCoordinate].types, STATIONARY_TURRET);
			// добавляем в соседнюю ячейку карты символ турели
			list::addBegin(&map[gameInfo->stationary_turret.yCoordinate + sideOfMovingOy][gameInfo->stationary_turret.xCoordinate].types, STATIONARY_TURRET);

			gameInfo->stationary_turret.yCoordinate = gameInfo->stationary_turret.yCoordinate + sideOfMovingOy;
		}
		break;

	case PLATFORM_TURRET:
		// если в соседней клетке проходимое пространство
		if (map[gameInfo->platform_turret.yCoordinate + 1][gameInfo->platform_turret.xCoordinate].passable == true)
		{
			// удаляем символ турели из текущей ячейки карты
			list::deleteCurrentElement(&map[gameInfo->platform_turret.yCoordinate][gameInfo->platform_turret.xCoordinate].types, PLATFORM_TURRET);
			// добавляем в соседнюю ячейку карты символ турели
			list::addBegin(&map[gameInfo->platform_turret.yCoordinate + sideOfMovingOy][gameInfo->platform_turret.xCoordinate].types, PLATFORM_TURRET);

			gameInfo->platform_turret.yCoordinate = gameInfo->platform_turret.yCoordinate + sideOfMovingOy;
		}
		break;
	}
}

void game::gravity(game::MapCell** map, GameInfo* gameInfo)
{
	int step = 1;
	// если в ячейке карты ниже героя проходимое пространство
	if (map[gameInfo->hero.yCoordinate][gameInfo->hero.xCoordinate].types->value == HERO &&
		map[gameInfo->hero.yCoordinate + 1][gameInfo->hero.xCoordinate].passable == true)
	{
		// перемещение героя вниз на одну ячейку карты
		moveOy(step, HERO, gameInfo, map);
	}
	// если в ячейке карты ниже турели проходимое пространство
	if (map[gameInfo->hunter_turret.yCoordinate][gameInfo->hunter_turret.xCoordinate].types->value == TURRET_HUNTER &&
		map[gameInfo->hunter_turret.yCoordinate + 1][gameInfo->hunter_turret.xCoordinate].passable == true)
	{
		// перемещение турели вниз на одну ячейку карты
		moveOy(step, TURRET_HUNTER, gameInfo, map);
	}
	// если в ячейке карты ниже турели проходимое пространство
	if (map[gameInfo->stationary_turret.yCoordinate][gameInfo->stationary_turret.xCoordinate].types->value == STATIONARY_TURRET &&
		map[gameInfo->stationary_turret.yCoordinate + 1][gameInfo->stationary_turret.xCoordinate].passable == true)
	{
		// перемещение турели вниз на одну ячейку карты
		moveOy(step, STATIONARY_TURRET, gameInfo, map);
	}

	if (map[gameInfo->platform_turret.yCoordinate][gameInfo->platform_turret.xCoordinate].types->value == PLATFORM_TURRET &&
		map[gameInfo->platform_turret.yCoordinate + 1][gameInfo->platform_turret.xCoordinate].passable == true)
	{
		// перемещение турели вниз на одну ячейку карты
		moveOy(step, PLATFORM_TURRET, gameInfo, map);
	}
}

// функция запуска уровня, отвчает за работу всей игры, принимает на вход название файла с уровнем
// возвращает структуру с данными о уровне, количестве очков и времени, затраченном на прохождение
records::DataAboutTheChampion* game::startLevel(char* levelName)
{
	game::GameInfo* gameInfo = new GameInfo;
	game::MapCell** map = game::createMap(levelName, gameInfo); // Создаем двумерный массив структур, используя текстовый документ
	records::DataAboutTheChampion* player = new records::DataAboutTheChampion;

	game::clearScreen(); // Чистим экран
	game::drawFrame(map, gameInfo); // Рисуем первый кадр
	bool playerPassedLevel = game::performAnAction(gameInfo, map); // Выполняем далее в зависимости от действий игрока

	system("cls");

	if (playerPassedLevel == true || playerPassedLevel == false) // Что то тут не так (я не про условие)
	{
		std::cout << "Please enter your name" << std::endl;

		std::cin >> player->name;

		player->score = gameInfo->hero.score;

		player->level = atoi(&levelName[4]); // Номер уровня находится в названии на пятом месте

		double score = gameInfo->hero.score;

		std::cout << "\n\n\t\t\tSCORE: " << score << std::endl;
		std::cout << "\t\t\tTIME: " << gameInfo->hero.time << std::endl;
		std::cout << "\n\n\t\t\tPRESS ANY KEY TO CONTINUE" << std::endl;
	}

	_getch();

	game::freeMemory(map, gameInfo); // Очищаем занятую память

	game::clearScreen(); // Чистим экран

	return player;
}

//-----Portals_Functions------//
// функция установки второго портала
// принимает на вход символ портала, структуру с информацией об объекте на карте и двумерный массив структур
void game::setPortal(char type, GameInfo* gameInfo, game::MapCell** map)
{
	if (type == RED_PORTAL)	// если устанавливется красный портал
	{
		// если красный портал существует
		if (gameInfo->redPortal.yCoordinate != 0)
			// удаляется символ существующего красного портала
			list::deleteCurrentElement(&map[gameInfo->redPortal.yCoordinate][gameInfo->redPortal.xCoordinate].types, RED_PORTAL);
		// координаты нового портала приравниваются координатам прицела
		gameInfo->redPortal.xCoordinate = gameInfo->aim.xCoordinate;
		gameInfo->redPortal.yCoordinate = gameInfo->aim.yCoordinate;

		// в ячейку карты, в которой находится прицел, добавляется символ красного портала
		list::addBegin(&map[gameInfo->aim.yCoordinate][gameInfo->aim.xCoordinate].types, RED_PORTAL);
	}

	else if (type == BLUE_PORTAL) // если устанавливется синий портал
	{
		// если синий портал уже существует
		if (gameInfo->bluePortal.yCoordinate != 0)
			// удаляется символ существующего красного портала
			list::deleteCurrentElement(&map[gameInfo->bluePortal.yCoordinate][gameInfo->bluePortal.xCoordinate].types, BLUE_PORTAL);
		// координаты нового портала приравниваются координатам прицела
		gameInfo->bluePortal.xCoordinate = gameInfo->aim.xCoordinate;
		gameInfo->bluePortal.yCoordinate = gameInfo->aim.yCoordinate;
		// в ячейку карты, в которой находится прицел, добавляется символ синего портала
		list::addBegin(&map[gameInfo->aim.yCoordinate][gameInfo->aim.xCoordinate].types, BLUE_PORTAL);
	}
}

// функция перехода по порталам, принимает структуру с информацией об объекте на карте и двумерный массив структур
void game::enterThePortal(char type, GameInfo* gameInfo, MapCell** map)
{
	// если персонаж и красный портал в одной клетке карты и существует синий портал
	if (gameInfo->hero.xCoordinate == gameInfo->redPortal.xCoordinate &&
		gameInfo->hero.yCoordinate == gameInfo->redPortal.yCoordinate &&
		gameInfo->bluePortal.yCoordinate != 0 && gameInfo->bluePortal.xCoordinate != 0)
	{
		// в ячейку карты по координатам синего портала добавляется символ героя
		list::addBegin(&map[gameInfo->bluePortal.yCoordinate][gameInfo->bluePortal.xCoordinate].types, HERO);
		// из ячейки карты по текущим координатам героя удаляется символ героя
		list::deleteCurrentElement(&map[gameInfo->hero.yCoordinate][gameInfo->hero.xCoordinate].types, HERO);
		// координаты героя приравниваются к координатам синего портала
		gameInfo->hero.xCoordinate = gameInfo->bluePortal.xCoordinate;
		gameInfo->hero.yCoordinate = gameInfo->bluePortal.yCoordinate;
	}
	// если персонаж и синий портал в одной клетке карты и существует красный портал
	else if (gameInfo->hero.xCoordinate == gameInfo->bluePortal.xCoordinate &&
		gameInfo->hero.yCoordinate == gameInfo->bluePortal.yCoordinate &&
		gameInfo->redPortal.yCoordinate != 0 && gameInfo->redPortal.xCoordinate != 0)
	{
		// в ячейку карты по координатам красного портала добавляется символ героя
		list::addBegin(&map[gameInfo->redPortal.yCoordinate][gameInfo->redPortal.xCoordinate].types, HERO);
		// из ячейки карты по текущим координатам героя удаляется символ героя
		list::deleteCurrentElement(&map[gameInfo->hero.yCoordinate][gameInfo->hero.xCoordinate].types, HERO);
		// координаты героя приравниваются к координатам синего портала
		gameInfo->hero.xCoordinate = gameInfo->redPortal.xCoordinate;
		gameInfo->hero.yCoordinate = gameInfo->redPortal.yCoordinate;
	}
}

//------Button_Functions------//
// функция активации клавиши, принимает структуру с информацией об объекте на карте и двумерный массив структур
void game::activateTheButton(GameInfo* gameInfo, MapCell** map)
{
	if (gameInfo->hero.xCoordinate == gameInfo->buttonOne.xCoordinate &&	// если персонаж и кнопка находятся в одной клетке
		gameInfo->hero.yCoordinate == gameInfo->buttonOne.yCoordinate &&	// и существует непроходимая стена
		map[gameInfo->blackWallOne.yCoordinate][gameInfo->blackWallOne.xCoordinate].types->value == BLACK_WALL)
	{
		// ячейка карты, в которой была непроходимая стена, становится проходимой
		map[gameInfo->blackWallOne.yCoordinate][gameInfo->blackWallOne.xCoordinate].passable = true;
		// на месте непроходимой стены отображается проходимая
		list::deleteCurrentElement(&map[gameInfo->blackWallOne.yCoordinate][gameInfo->blackWallOne.xCoordinate].types, BLACK_WALL);
		list::deleteCurrentElement(&map[gameInfo->buttonOne.yCoordinate][gameInfo->buttonOne.xCoordinate].types, BUTTON);
	}
	else if (gameInfo->hero.xCoordinate == gameInfo->buttonTwo.xCoordinate &&	// если персонаж и кнопка находятся в одной клетке
		gameInfo->hero.yCoordinate == gameInfo->buttonTwo.yCoordinate &&	// и существует непроходимая стена
		map[gameInfo->blackWallTwo.yCoordinate][gameInfo->blackWallTwo.xCoordinate].types->value == BLACK_WALL)
	{
		// ячейка карты, в которой была непроходимая стена, становится проходимой
		map[gameInfo->blackWallTwo.yCoordinate][gameInfo->blackWallTwo.xCoordinate].passable = true;
		// на месте непроходимой стены отображается проходимая
		list::deleteCurrentElement(&map[gameInfo->blackWallTwo.yCoordinate][gameInfo->blackWallTwo.xCoordinate].types, BLACK_WALL);
		list::deleteCurrentElement(&map[gameInfo->buttonTwo.yCoordinate][gameInfo->buttonTwo.xCoordinate].types, BUTTON);
	}
	else if (gameInfo->hero.xCoordinate == gameInfo->buttonThree.xCoordinate &&	// если персонаж и кнопка находятся в одной клетке
		gameInfo->hero.yCoordinate == gameInfo->buttonThree.yCoordinate &&	// и существует непроходимая стена
		map[gameInfo->blackWallThree.yCoordinate][gameInfo->blackWallThree.xCoordinate].types->value == BLACK_WALL)
	{
		// ячейка карты, в которой была непроходимая стена, становится проходимой
		map[gameInfo->blackWallThree.yCoordinate][gameInfo->blackWallThree.xCoordinate].passable = true;
		// на месте непроходимой стены отображается проходимая
		list::deleteCurrentElement(&map[gameInfo->blackWallThree.yCoordinate][gameInfo->blackWallThree.xCoordinate].types, BLACK_WALL);
		list::deleteCurrentElement(&map[gameInfo->buttonThree.yCoordinate][gameInfo->buttonThree.xCoordinate].types, BUTTON);
	}
	else if (gameInfo->hero.xCoordinate == gameInfo->buttonFour.xCoordinate &&	// если персонаж и кнопка находятся в одной клетке
		gameInfo->hero.yCoordinate == gameInfo->buttonFour.yCoordinate &&	// и существует непроходимая стена
		map[gameInfo->blackWallFour.yCoordinate][gameInfo->blackWallFour.xCoordinate].types->value == BLACK_WALL)
	{
		// ячейка карты, в которой была непроходимая стена, становится проходимой
		map[gameInfo->blackWallFour.yCoordinate][gameInfo->blackWallFour.xCoordinate].passable = true;
		// на месте непроходимой стены отображается проходимая
		list::deleteCurrentElement(&map[gameInfo->blackWallFour.yCoordinate][gameInfo->blackWallFour.xCoordinate].types, BLACK_WALL);
		list::deleteCurrentElement(&map[gameInfo->buttonFour.yCoordinate][gameInfo->buttonFour.xCoordinate].types, BUTTON);
	}
}

// функция перемещения прицела к герою
void game::replayceTheAimToHero(GameInfo* gameInfo, MapCell** map)
{
	// добавляется текстура прицела по координатам героя
	list::addBegin(&map[gameInfo->hero.yCoordinate][gameInfo->hero.xCoordinate].types, AIM_DOT);
	// удаляется текущая текстура прицела
	list::deleteCurrentElement(&map[gameInfo->aim.yCoordinate][gameInfo->aim.xCoordinate].types, AIM_DOT);
	
	// координатам прицела присваиваются координаты героя
	gameInfo->aim.xCoordinate = gameInfo->hero.xCoordinate;
	gameInfo->aim.yCoordinate = gameInfo->hero.yCoordinate;
}

// Функция проверяет, наступило ли событие, при котором игра должна закончиться
bool game::checkGameOverConditions(GameInfo* gameInfo, MapCell** map, bool gameIsRunning)
{
	if ((gameInfo->hero.xCoordinate == gameInfo->exitFromLevel.xCoordinate &&	// если персонаж находится в одной клетке с выходом
		gameInfo->hero.yCoordinate == gameInfo->exitFromLevel.yCoordinate))
	{
		return false;
	}
	else if (gameInfo->hero.healthPoints <= 0) // если здоровье игрока ниже или равно 0
	{
		return false;
	}
	else if (gameIsRunning == false)
	{
		return false;
	}
	else
	{
		return true;
	}
}

bool game::quitTheLevel(GameInfo* gameInfo, MapCell** map)
{
	std::cout << "\n\n\n\n\n\n\n\n\t   Quit the level?\n\n\t   Press 'y' or 'n'" << std::endl;

	switch (_getch())
	{
	case YES:
		gameInfo->hero.score = 0;
		gameInfo->hero.time = 100000.0;
		return false;
		break;

	case NO:
		drawFrame(map, gameInfo);
		return true;
		break;
	}
}

// функция паузы
double game::pause(GameInfo* gameInfo, MapCell** map)
{
	double startTime = clock();
	std::cout << "\n\n\n\n\n\n\n\n\t       Pause\n\n\t   Press any key" << std::endl;
	_getch();
	system("cls");
	double endTime = clock();
	return endTime - startTime;
}
